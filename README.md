#### Specyfying Dockerfile for environments

Our build process may differ from development to production environment.

For that reason, Docker provides us the `-f` flag (which stands for `--file`) to do so:

```sh
docker build -f Dockerfile.dev -t leonardosarmentocastro/frontend .
```

#### Mapping volumes

To make usage of features like "hot code reloading", we must abandon our previous approach of performing `COPY . .` into `Dockerfile`, because we will always have a file system snapshot that does not represent the real file we are editing (it will represent the file as it was when we built the image).

To do so, we need **map volumes**, which behaves like `symlinking` a folder:

```sh
docker run -it -p 3000:3000 -v /app/node_modules -v $(pwd):/app leonardosarmentocastro/frontend

## Creates a container and start it
docker run

## Attach listeners for STDIN/STOUT (interactive mode)
# Will give a nice output on your terminal and you will be able to interact with it, like using "control + c" to exit it.
-it

## Port mapping
# <our computer port> forward to <container port>
-p 3000:3000

## Bookmarked volume:
# Indicates that a given folder shouldn't be replaced by any other volume reference
# (we are going to use the "/node_modules" installed inside the container as instructed in our Dockerfile).
-v /app/node_modules

## Volume mapping:
# Just as port mapping, but for folders.
# `$(pwd)`: The current filesystem path where Dockerfile is being executed
# `/app`: The Docker working directory inside the container.
# Essentialy, we are telling Docker to use our "present working directory" as a reference for `/app` inside the container. Like a "symlink".
-v $(pwd):/app

## Image name to be run
leonardosarmentocastro/frontend
```

#### `docker-compose` to the rescue

As said many times, `docker-compose` comes to facilitate the usage of `docker-cli`.

To run `Dockerfile` with different names and map values for it, do as follows:

```sh
version: "3"
services:
  development:
    build:
      context: . # Specify the base directory to find all docker related files
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - /app/node_modules # Don't overwrite "/node_modules" when symlinking to the project outside the container.
      - .:/app # Symlink the entire project folder to our working directory.
```

A quick note regarding interactive shells for `docker-compose`:
When you define multiple services in a `docker-compose` file, all of them are going to be spinned up once `docker-compose up` is run.

Pretending you have the following `docker-compose.yml` file:

```yml
version: "3"
services:
  development:
    build:
      context: . # Specify the base directory to find all docker related files
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - /app/node_modules # Don't overwrite "/node_modules" when symlinking to the project outside the container.
      - .:/app # Symlink the entire project folder to our working directory.
  test:
    build:
      context: .
      dockerfile: Dockerfile.dev
    command: ["yarn", "test"]
    environment:
      CI: "true"
    volumes:
      - /app/node_modules
      - .:/app
```

You will not be able to interact with features like **watch mode** from `Jest` because we are not attached to its STDIN.

The work around is to perform a `docker exec -it <container id> yarn test` (where `container id` is the one create by `docker-compose` and can be listed with `docker ps`) in another terminal to interact with it.

#### Multi-stage build

It is a technique that consists on dividing our `Dockerfile` build process into containers as stages.

When it comes to deploy a `create-react-app` application, we need to perform two main tasks:

1. Install npm dependencies and build static assets
2. Serve the static assets

From step 1 to 2, we are not interested on copying the entire source code that was used to build the static assets, only the final `main.js` and `index.html` are of our interest.

That is why in our `Dockerfile`, we can define our base image as a `stage`.

Stages can be referred between them, which means that, from step 1 to 2, we can copy only the `/build/*.js|html|css` files generated by step 1.

```Dockerfile
## STAGE 1 - Building assets
# Install application dependencies and generates static css/html/js files.
FROM node:alpine as building_assets_stage
WORKDIR /frontend

# [cache-prone] Install dependencies
COPY ./package.json .
RUN yarn install

# [cache-prone] Copy all source files including installed dependencies
COPY . .
RUN yarn build

## STAGE 2 - Serving static content
# Copy the static css/html/js files generated by the previous stage to nginx directory.
# NOTE: defining a stage in this step is not necessary because we are not referring to it in any other step.
# It was only done for explanation purposes.
FROM nginx as serving_static_content_stage
COPY --from=building_assets_stage /frontend/build /usr/share/nginx/html
```
